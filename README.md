# Software-Test-Automation-QA

Hello everyone,

Overall, in my code, program, and software development for this repository, I tried to be as thorough as possible by making sure that everything is under control. In my summary and reflections report, I added that
in the software, JUnit tests that check if all possible cases of inputs are correct were constructed from tests that check only good (acceptable) inputs to tests that check only bad (unacceptable) inputs. The program ran properly with a coverage percentage of 80% or more. Besides testing functionality of the program, robust input validation was also in place to catch errors quickly and handle input errors properly.
The primary theme of the essay is about functionality, but using secure libraries and validating inputs is an important part of secure coding in order to prevent security vulnerabilities.

Delivering on user needs meant firstly correctly interpreting what those needs were, and then representing them in the program. This also meant careful prioritisation, ensuring important requirements must be implemented first, followed by the least important, after verifying that any top-priority requirement doesn’t rely on a lower-priority requirement that hasn’t yet been developed. The constraints on the contactID variable are a good example of this: they must be satisfied before the program can perform its other functions. As the program designer, I would have revisited and revised the code multiple times, ensuring that it complied with project specifications every step of the way. The JUnit tests I designed in response to a requirements document ask questions like ‘what acceptable inputs would a user provide to this program?’ and ‘what unacceptable inputs might a user provide, or what mistakes might they make, that the software should seriously consider when providing an output?’ In this way, software must be designed to anticipate and cater for a range of possible user scenarios: the scenarios the designer expects, but also the ones they might not have thought of.

In approaching software design, I employed a methodical strategy focused on structured testing and code clarity. By designing tests for specific functionalities and edge cases, I ensured that the software followed to project requirements. Additionally, I placed significant emphasis on commenting and formatting the JUnit tests, which facilitated code readability and maintainability. This iterative process, which included revisiting and refining the code based on feedback, underscores the importance of clear design and continuous improvement in developing effective software.
